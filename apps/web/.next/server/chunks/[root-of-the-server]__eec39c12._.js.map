{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///Users/anjukaranji/Desktop/projects/saybuild/src/app/api/parseTranscript/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\n\nexport async function POST(request: Request) {\n  try {\n    const { transcript, componentTree } = await request.json();\n\n    const groqResponse = await fetch(\n      \"https://api.groq.com/openai/v1/chat/completions\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${process.env.GROQ_API_KEY}`,\n        },\n        body: JSON.stringify({\n          model: \"llama-3.3-70b-versatile\",\n          messages: [\n            {\n              role: \"system\",\n              content: `You are a voice command parser for a page builder. Convert natural language into structured CRUD operations for UI components.\n\nCURRENT PAGE STATE (Component Tree):\n${JSON.stringify(componentTree, null, 2)}\n\nComponent Structure:\n- Each component has: key (uuid), alias (4-char short id), type (Box/Text/Button), props\n- Components can be nested (Box can have children array)\n- Use the component's \"key\" or \"alias\" to target specific components\n- When user says \"the blue text\", find component by matching props (color, text content, etc.)\n\nReturn ONLY valid JSON in this exact format:\n{\n  \"commands\": [\n    {\n      \"operation\": \"CREATE\" | \"READ\" | \"UPDATE\" | \"DELETE\",\n      \"targetKey\": \"component-key-or-alias-if-updating-deleting\",\n      \"componentType\": \"Box\" | \"Text\" | \"Button\",\n      \"props\": {},\n      \"parentKey\": \"parent-key-if-creating-nested-component\"\n    }\n  ]\n}\n\nExamples:\n1. \"Make the blue text bigger\"\n   - Find Text component with color \"#3980eaff\"\n   - Return: {\"operation\": \"UPDATE\", \"targetKey\": \"found-key\", \"componentType\": \"Text\", \"props\": {\"fontSize\": 60}}\n\n2. \"Delete the sign up button\"\n   - Find Box containing Text with \"SIGN UP FREE\"\n   - Return: {\"operation\": \"DELETE\", \"targetKey\": \"found-box-key\", \"componentType\": \"Box\", \"props\": {}}\n\n3. \"Add a red button that says Click Me\"\n   - Return: {\"operation\": \"CREATE\", \"componentType\": \"Button\", \"props\": {\"text\": \"Click Me\", \"backgroundColor\": \"red\"}, \"parentKey\": \"root-or-parent-key\"}\n\n4. \"Change the demo button background to green\"\n   - Find Box containing Text with \"REQUEST A DEMO\"\n   - Return: {\"operation\": \"UPDATE\", \"targetKey\": \"found-box-key\", \"componentType\": \"Box\", \"props\": {\"backgroundColor\": \"green\"}}\n\n5. \"Make it blue\" (ambiguous - use context to determine what \"it\" refers to, likely the most recently created/modified component)\n\nIMPORTANT:\n- Use actual key/alias values from the component tree\n- When updating nested components, target the correct parent/child\n- Match components by their text content, colors, or position in tree\n- For ambiguous references (\"it\", \"that\", \"the button\"), use context to identify the right component\n\nReturn only JSON, no explanations.`,\n            },\n            {\n              role: \"user\",\n              content: `Parse this transcript into commands: ${transcript}`,\n            },\n          ],\n          temperature: 0.2,\n          response_format: { type: \"json_object\" },\n        }),\n      }\n    );\n\n    if (!groqResponse.ok) {\n      const errorText = await groqResponse.text();\n      console.error(\"‚ùå Groq API Error:\", errorText);\n      throw new Error(`Groq API error: ${errorText}`);\n    }\n\n    const groqData = await groqResponse.json();\n    const parsedContent = groqData.choices[0].message.content;\n\n    const commandsObject = JSON.parse(parsedContent);\n    console.log(\"‚úÖ Commands Object:\", commandsObject);\n\n    return NextResponse.json({\n      success: true,\n      message: \"Transcript parsed successfully\",\n      commands: commandsObject.commands,\n    });\n  } catch (error) {\n    console.error(\"üí• Error:\", error);\n    return NextResponse.json(\n      {\n        success: false,\n        error: \"Failed to parse transcript\",\n        details: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,EAAE,UAAU,EAAE,aAAa,EAAE,GAAG,MAAM,QAAQ,IAAI;QAExD,MAAM,eAAe,MAAM,MACzB,mDACA;YACE,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,eAAe,CAAC,OAAO,EAAE,QAAQ,GAAG,CAAC,YAAY,EAAE;YACrD;YACA,MAAM,KAAK,SAAS,CAAC;gBACnB,OAAO;gBACP,UAAU;oBACR;wBACE,MAAM;wBACN,SAAS,CAAC;;;AAGxB,EAAE,KAAK,SAAS,CAAC,eAAe,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCA6CP,CAAC;oBACvB;oBACA;wBACE,MAAM;wBACN,SAAS,CAAC,qCAAqC,EAAE,YAAY;oBAC/D;iBACD;gBACD,aAAa;gBACb,iBAAiB;oBAAE,MAAM;gBAAc;YACzC;QACF;QAGF,IAAI,CAAC,aAAa,EAAE,EAAE;YACpB,MAAM,YAAY,MAAM,aAAa,IAAI;YACzC,QAAQ,KAAK,CAAC,qBAAqB;YACnC,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,WAAW;QAChD;QAEA,MAAM,WAAW,MAAM,aAAa,IAAI;QACxC,MAAM,gBAAgB,SAAS,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO;QAEzD,MAAM,iBAAiB,KAAK,KAAK,CAAC;QAClC,QAAQ,GAAG,CAAC,sBAAsB;QAElC,OAAO,+TAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;YACT,UAAU,eAAe,QAAQ;QACnC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,aAAa;QAC3B,OAAO,+TAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}